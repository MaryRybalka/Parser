string ParseToplevel(List<Token> tokens)
    {
        List<string> prog = new List<string>();
        foreach (Token token in tokens)
        {
            prog.Add(ParseExpression(token));
        }

        return "{\n type: \"prog\",\n prog: " + prog + "}";
    }

    string ParseFunction()
    {
        return "{\n type: \"function\",\n vars: " +
               ParseVarnames() +
               "\",\n body: \" " +
               ParseBody() +
               "\"}";
    }

    string ParseIf()
    {
        string cond = ParseExpression();
        if (!is_punc("{")) skip_kw("then");
        string then = ParseExpression();
        string ret = "{\n type: \"if\",\n cond: " + cond +
                     "\",\n then: \" " + then + "\"}";
        if (is_kw("else"))
        {
            string _else = ParseExpression();
            ret = ret + ",\n else: " + _else;
        }

        return ret;
    }

    string ParseAtom(Token token)
    {
        if (is_punc("("))
        {
            var exp = ParseExpression();
            skip_punc(")");
            return exp;
        }

        if (is_punc("{")) return ParseProg();
        if (is_kw("if")) return ParseIf();
        if (is_kw("true") || is_kw("false")) return ParseBool();
        if (is_kw("func") || is_kw("Î»"))
        {
            return ParseFunction();
        }

        var tok = input.next();
        if (tok.type == "var" || tok.type == "num" || tok.type == "str")
            return tok;
        unexpected();
    }
    
    string ParseExpression(Token token) {
        if (token.status == "STAR" || 
            token.status == "SLASH" || 
            token.status == "PLUS" || 
            token.status == "MINUS" || 
            token.status == "EQUAL" || 
            token.status == "OROR" || 
            token.status == "ANDAND" || 
            token.status == "LESS" || 
            token.status == "MORE" || 
            token.status == "LESSOREQUAL" || 
            token.status == "MOREOREQUAL" || 
            token.status == "TWO_EQUAL" || 
            token.status == "NOTEQUAL" ||
            token.status == "PERCENT")
            return MaybeBinary(ParseAtom(token), 0);
        return ParseAtom(token);
    }
    
    string MaybeBinary(string left, int prec) {
        string tok = is_op();
        if (tok) {
            byte his_prec = (Precedence)tok.value;// using Microsoft.VisualBasic;
            
            if (his_prec > prec) {
                input.next();
                string right = MaybeBinary(ParseAtom(), his_prec); // (*);
                string binary = "{\n type     : " + tok.value == "=" ? "assign" : "binary" + 
                    ",\n operator :  " + tok.value + 
                    ",\n left     : " + left +
                    ",\n right    : " + right + "}";
                return MaybeBinary(binary, prec);
            }
        }
        return left;
    }
    
    
    
    public struct nnRule
    {
        nu leftPart;
        nu[] rightPart;

        public nnRule(nu left, nu[] right)
        {
            this.leftPart = left;
            this.rightPart = right;
        }

        public nu getLeftPart()
        {
            return leftPart;
        }

        public nu[] getRightPart()
        {
            return rightPart;
        }
    }

    public struct nsRule
    {
        nu leftPart;
        string[] rightPart;

        public nsRule(nu left, string[] right)
        {
            this.leftPart = left;
            this.rightPart = right;
        }

        public nu getLeftPart()
        {
            return leftPart;
        }

        public string[] getRightPart()
        {
            return rightPart;
        }
    }

    public struct mixRule
    {
        nu leftPart;
        nu[] rightPart;

        public mixRule(nu left, nu[] right)
        {
            this.leftPart = left;
            this.rightPart = right;
        }

        public nu getLeftPart()
        {
            return leftPart;
        }

        public nu[] getRightPart()
        {
            return rightPart;
        }
    }

    
        nnRules = new nnRule[]
        {
            new nnRule(nu.Program, new[] {nu.Sentences}),

            new nnRule(nu.Sentences, new[] {nu.Sentence}),
            new nnRule(nu.Sentences, new[] {nu.Sentence, nu.Sentences}),

            new nnRule(nu.Sentence, new[] {nu.Expressions}),
            new nnRule(nu.Sentence, new[] {nu.Definitions}),
            new nnRule(nu.Sentence, new[] {nu.Cycle}),
            new nnRule(nu.Sentence, new[] {nu.IfBranching}),

            new nnRule(nu.CodeBlock, new[] {nu.Sentences}),

            new nnRule(nu.Expression, new[] {nu.Operand, nu.BinaryOperator, nu.Operand}),
            new nnRule(nu.Expression, new[] {nu.UnaryOperator, nu.Operand}),
            new nnRule(nu.Expression, new[] {nu.Operand, nu.UnaryOperator}),
            new nnRule(nu.Operand, new[] {nu.Identifier}),
            new nnRule(nu.Operand, new[] {nu.Literal}),
            new nnRule(nu.Operand, new[] {nu.Identifier, nu.FunctionCall}),
            new nnRule(nu.Operand, new[] {nu.Literal, nu.FunctionCall}),

            new nnRule(nu.ArgumentsList, new[] {nu.Argument}),
            new nnRule(nu.Argument, new[] {nu.Expression}),
            new nnRule(nu.Expressions, new[] {nu.Expression}),
            new nnRule(nu.Expressions, new[] {nu.Expression, nu.Expressions}),

            // new nnRule(nu.BinaryOperator, new[] {nu.BinaryOperatorStart, nu.OperatorSymbols}),
            // new nnRule(nu.BinaryOperator, new[] {nu.DotOperatorStart, nu.DotOperatorSymbols}),
            //
            // new nnRule(nu.DotOperatorSymbols, new[] {nu.DotOperatorSymbol, nu.DotOperatorSymbols}),

            new nnRule(nu.Definitions, new[] {nu.Definition}),
            new nnRule(nu.Definitions, new[] {nu.Definition, nu.Definitions}),

            new nnRule(nu.InitialisationListPattern, new[] {nu.PatternInitialisator}),
            new nnRule(nu.InitialisationListPattern, new[] {nu.PatternInitialisator, nu.InitialisationListPattern}),

            new nnRule(nu.PatternInitialisator, new[] {nu.Identifier, nu.Initialisator}),
            new nnRule(nu.PatternInitialisator, new[] {nu.Identifier, nu.TypeAnnotation, nu.Initialisator}),

            // new nnRule(nu.Cycle, new[] {nu.ForInCycle}),
            // new nnRule(nu.Cycle, new[] {nu.WhileCycle}),

            new nnRule(nu.Condition, new[] {nu.Expression}),
            // new nnRule(nu.Condition, new[] {nu.TransformationOptional}),

            // new nnRule(nu.Identifier, new[] {nu.IdentificatorsStart}),
            // new nnRule(nu.Identifier, new[] {nu.IdentificatorsStart, nu.IdentificatorsSymbols}),
            // new nnRule(nu.IdentificatorSymbol, new[] {nu.IdentificatorsStart}),
            // new nnRule(nu.IdentificatorsSymbols, new[] {nu.IdentificatorsStart}),

            new nnRule(nu.Literal, new[] {nu.NumberLiteral}),
            new nnRule(nu.Literal, new[] {nu.StringLiteral}),
            new nnRule(nu.Literal, new[] {nu.BoolLiteral}),
        };

        nsRules = new nsRule[]
        {
            new nsRule(nu.Program, new[] {sigma[nu.SigmaLambda]}),

            new nsRule(nu.FunctionCall, new[] {sigma[nu.SigmaOpenRound] + sigma[nu.SigmaCloseRound]}),

            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaSlash]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaEqual]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaMinus]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaPlus]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaStar]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaPercent]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaMore]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaLess]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaAnd] + sigma[nu.SigmaAnd]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaOr] + sigma[nu.SigmaOr]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaMore] + sigma[nu.SigmaEqual]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaLess] + sigma[nu.SigmaEqual]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaEqual] + sigma[nu.SigmaEqual]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaNot] + sigma[nu.SigmaEqual]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaDot]}),

            new nsRule(nu.UnaryOperator, new[] {sigma[nu.SigmaNot]}),
            new nsRule(nu.UnaryOperator, new[] {sigma[nu.SigmaMinus] + sigma[nu.SigmaMinus]}),
            new nsRule(nu.UnaryOperator, new[] {sigma[nu.SigmaPlus] + sigma[nu.SigmaPlus]}),

            // new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaLambda]}),

            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaSlash]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaEqual]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaMinus]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaPlus]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaNot]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaStar]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaPercent]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaMore]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaLess]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaAnd] + sigma[nu.SigmaAnd]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaOr] + sigma[nu.SigmaOr]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaMore] + sigma[nu.SigmaEqual]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaLess] + sigma[nu.SigmaEqual]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaEqual] + sigma[nu.SigmaEqual]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaNot] + sigma[nu.SigmaEqual]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaDot]}),

            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaSlash]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaEqual]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaMinus]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaPlus]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaNot]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaStar]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaPercent]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaMore]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaLess]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaAnd]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaOr]}),
            //
            // new nsRule(nu.DotOperatorStart, new[] {sigma[nu.SigmaDot]}),
            // new nsRule(nu.DotOperatorSymbol, new[] {sigma[nu.SigmaDot]}),
            // new nsRule(nu.DotOperatorSymbols, new[] {sigma[nu.SigmaLambda]}),

            new nsRule(nu.Sentence, new[] {sigma[nu.SigmaBreak]}),
            new nsRule(nu.Sentence, new[] {sigma[nu.SigmaContinue]}),

            new nsRule(nu.BoolLiteral, new[] {sigma[nu.SigmaTrue]}),
            new nsRule(nu.BoolLiteral, new[] {sigma[nu.SigmaFalse]}),
        };

        mixRules = new mixRule[]
        {
            new mixRule(nu.FunctionCall, new[] {nu.SigmaOpenRound, nu.ArgumentsList, nu.SigmaCloseRound}),
            new mixRule(nu.ArgumentsList, new[] {nu.Argument, nu.SigmaComma, nu.ArgumentsList}),
            new mixRule(nu.Argument, new[] {nu.Identifier, nu.SigmaDoubleDot, nu.Expression}),

            new mixRule(nu.Definition, new[] {nu.SigmaLet, nu.InitialisationListPattern}),
            new mixRule(nu.Definition, new[] {nu.SigmaVar, nu.InitialisationListPattern}),

            new mixRule(nu.TypeAnnotation, new[] {nu.SigmaDoubleDot, nu.Identifier}),
            new mixRule(nu.TypeAnnotation, new[] {nu.SigmaDoubleDot, nu.Identifier, nu.SigmaQuest}),

            new mixRule(nu.Initialisator, new[] {nu.SigmaEqual, nu.Expression}),
            new mixRule(nu.Initialisator, new[] {nu.SigmaEqual, nu.Operand}),

            new mixRule(nu.Cycle, new[] {nu.SigmaFor, nu.Pattern, nu.SigmaIn, nu.Expression, nu.CodeBlock}),
            new mixRule(nu.Cycle, new[] {nu.SigmaWhile, nu.Condition, nu.CodeBlock}),

            new mixRule(nu.Condition, new[] {nu.SigmaLet, nu.Pattern, nu.Initialisator}),
            new mixRule(nu.Condition, new[] {nu.SigmaVar, nu.Pattern, nu.Initialisator}),

            new mixRule(nu.IfBranching, new[] {nu.SigmaIf, nu.Condition, nu.CodeBlock, nu.ElseBlock}),
            new mixRule(nu.IfBranching, new[] {nu.SigmaIf, nu.Condition, nu.CodeBlock}),
            new mixRule(nu.ElseBlock, new[] {nu.SigmaElse, nu.CodeBlock}),
            new mixRule(nu.ElseBlock, new[] {nu.SigmaElse, nu.IfBranching}),
        };
        
        Helper, // Ð²ÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°ÑÐµÐ»ÑÐ½ÑÐ¹ Ð½ÐµÑÐµÑÐ¼Ð¸Ð½Ð°Ð»
        Program, // Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð°
        Sentence, //Ð¿ÑÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ
        Expression, //Ð²ÑÑÐ°Ð¶ÐµÐ½Ð¸Ðµ
        Definition, //Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ
        Cycle, //ÑÐ¸ÐºÐ»
        Branching, //Ð²ÐµÑÐ²Ð»ÐµÐ½Ð¸Ðµ
        ControlSentence, //ÐºÐ¾Ð½ÑÑÐ¾Ð»ÑÐ½Ð¾Ðµ Ð¿ÑÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ
        Sentences, //Ð¿ÑÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ
        CodeBlock, //ÐºÐ¾Ð´-Ð±Ð»Ð¾Ðº
        BinaryOperator, //Ð±Ð¸Ð½Ð°ÑÐ½ÑÐ¹ Ð¾Ð¿ÐµÑÐ°ÑÐ¾Ñ
        BinaryOperatorStart, //Ð±Ð¸Ð½Ð°ÑÐ½ÑÐ¹ Ð¾Ð¿ÐµÑÐ°ÑÐ¾Ñ Ð½Ð°ÑÐ°Ð»Ð¾
        UnaryOperator,
        DotOperatorStart,
        DotOperatorSymbols,
        DotOperatorSymbol,
        OperatorSymbols, // Ð¾Ð¿ÐµÑÐ°ÑÐ¾Ñ ÑÐ¸Ð¼Ð²Ð¾Ð»Ñ
        OperatorSymbol, // Ð¾Ð¿ÐµÑÐ°ÑÐ¾Ñ ÑÐ¸Ð¼Ð²Ð¾Ð»
        Operand, //Ð¾Ð¿ÑÐµÐ°Ð½Ð´
        Identifier, //Ð¸Ð´ÐµÐ½ÑÐ¸ÑÐ¸ÐºÐ°ÑÐ¾Ñ
        Literal, //Ð»Ð¸ÑÐµÑÐ°Ð»
        FunctionCall, //Ð²ÑÐ·Ð¾Ð² ÑÑÐ½ÐºÑÐ¸Ð¸
        ArgumentsList, //ÑÐ¿Ð¸ÑÐ¾Ðº Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÐ¾Ð²
        Argument, //Ð°ÑÐ³ÑÐ¼ÐµÐ½Ñ
        Expressions, //Ð²ÑÑÑÐ¶ÐµÐ½Ð¸Ñ
        ConstantDefinition, //Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð½ÑÑÐ°Ð½ÑÑ
        VariableDefinition, //Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹
        TypeAnnotation,
        Definitions, //Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ
        InitialisationListPattern, //ÑÐ¿Ð¸ÑÐ¾Ðº Ð¸Ð½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸ Ð¿Ð°ÑÑÐµÑÐ½
        PatternInitialisator, // Ð¿Ð°ÑÑÐµÑÐ½ Ð¸Ð½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¾Ñ
        Pattern, //Ð¿Ð°ÑÑÐµÑÐ½
        Initialisator, //Ð¸Ð½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¾Ñ
        ForInCycle,
        WhileCycle,
        Condition, //ÑÑÐ»Ð¾Ð²Ð¸Ðµ
        TransformationOptional, //Ð¿ÑÐµÐ¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ optional
        IfBranching,
        ElseBlock,
        IdentificatorsStart,
        IdentificatorsSymbols, //ÑÐ¸Ð¼Ð²Ð¾Ð»Ñ Ð¸Ð´ÐµÐ½ÑÐ¸ÑÐ¸ÐºÐ°ÑÐ¾ÑÐ°
        IdentificatorSymbol, //Ð¸Ð´ÐµÐ½ÑÐ¸ÑÐ¸ÐºÐ°ÑÐ¾Ñ ÑÐ¸Ð¼Ð²Ð¾Ð»
        NumberLiteral, //ÑÐ¸ÑÐ»ÐµÐ½Ð½ÑÐ¹ Ð»Ð¸ÑÐµÑÐ°Ð»
        StringLiteral,
        BoolLiteral,
        IntNumberLiteral,
        FloatNumberLiteral,
        DecimalNumber,
        DecimalSymbols,
        DecimalSymbol,
        FloatPart,
        Exp, //ÐµÐºÑÐ¿Ð¾Ð½ÐµÐ½ÑÐ°
        Sign, //Ð·Ð½Ð°Ðº

        SigmaLetters,
        SigmaNumbers,
        SigmaOpenRound,
        SigmaCloseRound,
        SigmaOpenCurl,
        SigmaCloseCurl,
        SigmaEqual,
        SigmaSlash,
        SigmaStar,
        SigmaPlus,
        SigmaMinus,
        SigmaPercent,
        SigmaNot,
        SigmaQuest,
        SigmaMore,
        SigmaLess,
        SigmaDot,
        SigmaDoubleDot,
        SigmaComma,
        SigmaLambda,
        SigmaAnd,
        SigmaOr,
        SigmaFor,
        SigmaIf,
        SigmaIn,
        SigmaLet,
        SigmaVar,
        SigmaWhile,
        SigmaElse,
        SigmaBreak,
        SigmaContinue,
        SigmaTrue,
        SigmaFalse,