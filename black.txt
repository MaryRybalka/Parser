string ParseToplevel(List<Token> tokens)
    {
        List<string> prog = new List<string>();
        foreach (Token token in tokens)
        {
            prog.Add(ParseExpression(token));
        }

        return "{\n type: \"prog\",\n prog: " + prog + "}";
    }

    string ParseFunction()
    {
        return "{\n type: \"function\",\n vars: " +
               ParseVarnames() +
               "\",\n body: \" " +
               ParseBody() +
               "\"}";
    }

    string ParseIf()
    {
        string cond = ParseExpression();
        if (!is_punc("{")) skip_kw("then");
        string then = ParseExpression();
        string ret = "{\n type: \"if\",\n cond: " + cond +
                     "\",\n then: \" " + then + "\"}";
        if (is_kw("else"))
        {
            string _else = ParseExpression();
            ret = ret + ",\n else: " + _else;
        }

        return ret;
    }

    string ParseAtom(Token token)
    {
        if (is_punc("("))
        {
            var exp = ParseExpression();
            skip_punc(")");
            return exp;
        }

        if (is_punc("{")) return ParseProg();
        if (is_kw("if")) return ParseIf();
        if (is_kw("true") || is_kw("false")) return ParseBool();
        if (is_kw("func") || is_kw("λ"))
        {
            return ParseFunction();
        }

        var tok = input.next();
        if (tok.type == "var" || tok.type == "num" || tok.type == "str")
            return tok;
        unexpected();
    }
    
    string ParseExpression(Token token) {
        if (token.status == "STAR" || 
            token.status == "SLASH" || 
            token.status == "PLUS" || 
            token.status == "MINUS" || 
            token.status == "EQUAL" || 
            token.status == "OROR" || 
            token.status == "ANDAND" || 
            token.status == "LESS" || 
            token.status == "MORE" || 
            token.status == "LESSOREQUAL" || 
            token.status == "MOREOREQUAL" || 
            token.status == "TWO_EQUAL" || 
            token.status == "NOTEQUAL" ||
            token.status == "PERCENT")
            return MaybeBinary(ParseAtom(token), 0);
        return ParseAtom(token);
    }
    
    string MaybeBinary(string left, int prec) {
        string tok = is_op();
        if (tok) {
            byte his_prec = (Precedence)tok.value;// using Microsoft.VisualBasic;
            
            if (his_prec > prec) {
                input.next();
                string right = MaybeBinary(ParseAtom(), his_prec); // (*);
                string binary = "{\n type     : " + tok.value == "=" ? "assign" : "binary" + 
                    ",\n operator :  " + tok.value + 
                    ",\n left     : " + left +
                    ",\n right    : " + right + "}";
                return MaybeBinary(binary, prec);
            }
        }
        return left;
    }
    
    
    
    public struct nnRule
    {
        nu leftPart;
        nu[] rightPart;

        public nnRule(nu left, nu[] right)
        {
            this.leftPart = left;
            this.rightPart = right;
        }

        public nu getLeftPart()
        {
            return leftPart;
        }

        public nu[] getRightPart()
        {
            return rightPart;
        }
    }

    public struct nsRule
    {
        nu leftPart;
        string[] rightPart;

        public nsRule(nu left, string[] right)
        {
            this.leftPart = left;
            this.rightPart = right;
        }

        public nu getLeftPart()
        {
            return leftPart;
        }

        public string[] getRightPart()
        {
            return rightPart;
        }
    }

    public struct mixRule
    {
        nu leftPart;
        nu[] rightPart;

        public mixRule(nu left, nu[] right)
        {
            this.leftPart = left;
            this.rightPart = right;
        }

        public nu getLeftPart()
        {
            return leftPart;
        }

        public nu[] getRightPart()
        {
            return rightPart;
        }
    }

    
        nnRules = new nnRule[]
        {
            new nnRule(nu.Program, new[] {nu.Sentences}),

            new nnRule(nu.Sentences, new[] {nu.Sentence}),
            new nnRule(nu.Sentences, new[] {nu.Sentence, nu.Sentences}),

            new nnRule(nu.Sentence, new[] {nu.Expressions}),
            new nnRule(nu.Sentence, new[] {nu.Definitions}),
            new nnRule(nu.Sentence, new[] {nu.Cycle}),
            new nnRule(nu.Sentence, new[] {nu.IfBranching}),

            new nnRule(nu.CodeBlock, new[] {nu.Sentences}),

            new nnRule(nu.Expression, new[] {nu.Operand, nu.BinaryOperator, nu.Operand}),
            new nnRule(nu.Expression, new[] {nu.UnaryOperator, nu.Operand}),
            new nnRule(nu.Expression, new[] {nu.Operand, nu.UnaryOperator}),
            new nnRule(nu.Operand, new[] {nu.Identifier}),
            new nnRule(nu.Operand, new[] {nu.Literal}),
            new nnRule(nu.Operand, new[] {nu.Identifier, nu.FunctionCall}),
            new nnRule(nu.Operand, new[] {nu.Literal, nu.FunctionCall}),

            new nnRule(nu.ArgumentsList, new[] {nu.Argument}),
            new nnRule(nu.Argument, new[] {nu.Expression}),
            new nnRule(nu.Expressions, new[] {nu.Expression}),
            new nnRule(nu.Expressions, new[] {nu.Expression, nu.Expressions}),

            // new nnRule(nu.BinaryOperator, new[] {nu.BinaryOperatorStart, nu.OperatorSymbols}),
            // new nnRule(nu.BinaryOperator, new[] {nu.DotOperatorStart, nu.DotOperatorSymbols}),
            //
            // new nnRule(nu.DotOperatorSymbols, new[] {nu.DotOperatorSymbol, nu.DotOperatorSymbols}),

            new nnRule(nu.Definitions, new[] {nu.Definition}),
            new nnRule(nu.Definitions, new[] {nu.Definition, nu.Definitions}),

            new nnRule(nu.InitialisationListPattern, new[] {nu.PatternInitialisator}),
            new nnRule(nu.InitialisationListPattern, new[] {nu.PatternInitialisator, nu.InitialisationListPattern}),

            new nnRule(nu.PatternInitialisator, new[] {nu.Identifier, nu.Initialisator}),
            new nnRule(nu.PatternInitialisator, new[] {nu.Identifier, nu.TypeAnnotation, nu.Initialisator}),

            // new nnRule(nu.Cycle, new[] {nu.ForInCycle}),
            // new nnRule(nu.Cycle, new[] {nu.WhileCycle}),

            new nnRule(nu.Condition, new[] {nu.Expression}),
            // new nnRule(nu.Condition, new[] {nu.TransformationOptional}),

            // new nnRule(nu.Identifier, new[] {nu.IdentificatorsStart}),
            // new nnRule(nu.Identifier, new[] {nu.IdentificatorsStart, nu.IdentificatorsSymbols}),
            // new nnRule(nu.IdentificatorSymbol, new[] {nu.IdentificatorsStart}),
            // new nnRule(nu.IdentificatorsSymbols, new[] {nu.IdentificatorsStart}),

            new nnRule(nu.Literal, new[] {nu.NumberLiteral}),
            new nnRule(nu.Literal, new[] {nu.StringLiteral}),
            new nnRule(nu.Literal, new[] {nu.BoolLiteral}),
        };

        nsRules = new nsRule[]
        {
            new nsRule(nu.Program, new[] {sigma[nu.SigmaLambda]}),

            new nsRule(nu.FunctionCall, new[] {sigma[nu.SigmaOpenRound] + sigma[nu.SigmaCloseRound]}),

            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaSlash]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaEqual]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaMinus]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaPlus]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaStar]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaPercent]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaMore]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaLess]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaAnd] + sigma[nu.SigmaAnd]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaOr] + sigma[nu.SigmaOr]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaMore] + sigma[nu.SigmaEqual]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaLess] + sigma[nu.SigmaEqual]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaEqual] + sigma[nu.SigmaEqual]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaNot] + sigma[nu.SigmaEqual]}),
            new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaDot]}),

            new nsRule(nu.UnaryOperator, new[] {sigma[nu.SigmaNot]}),
            new nsRule(nu.UnaryOperator, new[] {sigma[nu.SigmaMinus] + sigma[nu.SigmaMinus]}),
            new nsRule(nu.UnaryOperator, new[] {sigma[nu.SigmaPlus] + sigma[nu.SigmaPlus]}),

            // new nsRule(nu.BinaryOperator, new[] {sigma[nu.SigmaLambda]}),

            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaSlash]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaEqual]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaMinus]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaPlus]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaNot]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaStar]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaPercent]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaMore]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaLess]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaAnd] + sigma[nu.SigmaAnd]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaOr] + sigma[nu.SigmaOr]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaMore] + sigma[nu.SigmaEqual]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaLess] + sigma[nu.SigmaEqual]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaEqual] + sigma[nu.SigmaEqual]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaNot] + sigma[nu.SigmaEqual]}),
            // new nsRule(nu.OperatorSymbol, new[] {sigma[nu.SigmaDot]}),

            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaSlash]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaEqual]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaMinus]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaPlus]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaNot]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaStar]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaPercent]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaMore]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaLess]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaAnd]}),
            // new nsRule(nu.BinaryOperatorStart, new[] {sigma[nu.SigmaOr]}),
            //
            // new nsRule(nu.DotOperatorStart, new[] {sigma[nu.SigmaDot]}),
            // new nsRule(nu.DotOperatorSymbol, new[] {sigma[nu.SigmaDot]}),
            // new nsRule(nu.DotOperatorSymbols, new[] {sigma[nu.SigmaLambda]}),

            new nsRule(nu.Sentence, new[] {sigma[nu.SigmaBreak]}),
            new nsRule(nu.Sentence, new[] {sigma[nu.SigmaContinue]}),

            new nsRule(nu.BoolLiteral, new[] {sigma[nu.SigmaTrue]}),
            new nsRule(nu.BoolLiteral, new[] {sigma[nu.SigmaFalse]}),
        };

        mixRules = new mixRule[]
        {
            new mixRule(nu.FunctionCall, new[] {nu.SigmaOpenRound, nu.ArgumentsList, nu.SigmaCloseRound}),
            new mixRule(nu.ArgumentsList, new[] {nu.Argument, nu.SigmaComma, nu.ArgumentsList}),
            new mixRule(nu.Argument, new[] {nu.Identifier, nu.SigmaDoubleDot, nu.Expression}),

            new mixRule(nu.Definition, new[] {nu.SigmaLet, nu.InitialisationListPattern}),
            new mixRule(nu.Definition, new[] {nu.SigmaVar, nu.InitialisationListPattern}),

            new mixRule(nu.TypeAnnotation, new[] {nu.SigmaDoubleDot, nu.Identifier}),
            new mixRule(nu.TypeAnnotation, new[] {nu.SigmaDoubleDot, nu.Identifier, nu.SigmaQuest}),

            new mixRule(nu.Initialisator, new[] {nu.SigmaEqual, nu.Expression}),
            new mixRule(nu.Initialisator, new[] {nu.SigmaEqual, nu.Operand}),

            new mixRule(nu.Cycle, new[] {nu.SigmaFor, nu.Pattern, nu.SigmaIn, nu.Expression, nu.CodeBlock}),
            new mixRule(nu.Cycle, new[] {nu.SigmaWhile, nu.Condition, nu.CodeBlock}),

            new mixRule(nu.Condition, new[] {nu.SigmaLet, nu.Pattern, nu.Initialisator}),
            new mixRule(nu.Condition, new[] {nu.SigmaVar, nu.Pattern, nu.Initialisator}),

            new mixRule(nu.IfBranching, new[] {nu.SigmaIf, nu.Condition, nu.CodeBlock, nu.ElseBlock}),
            new mixRule(nu.IfBranching, new[] {nu.SigmaIf, nu.Condition, nu.CodeBlock}),
            new mixRule(nu.ElseBlock, new[] {nu.SigmaElse, nu.CodeBlock}),
            new mixRule(nu.ElseBlock, new[] {nu.SigmaElse, nu.IfBranching}),
        };
        
        Helper, // вспомогательный нетерминал
        Program, // программа
        Sentence, //предложение
        Expression, //выражение
        Definition, //определение
        Cycle, //цикл
        Branching, //ветвление
        ControlSentence, //контрольное предложение
        Sentences, //предложения
        CodeBlock, //код-блок
        BinaryOperator, //бинарный оператор
        BinaryOperatorStart, //бинарный оператор начало
        UnaryOperator,
        DotOperatorStart,
        DotOperatorSymbols,
        DotOperatorSymbol,
        OperatorSymbols, // оператор символы
        OperatorSymbol, // оператор символ
        Operand, //опреанд
        Identifier, //идентификатор
        Literal, //литерал
        FunctionCall, //вызов функции
        ArgumentsList, //список аргументов
        Argument, //аргумент
        Expressions, //вырфжения
        ConstantDefinition, //определение константы
        VariableDefinition, //определение переменной
        TypeAnnotation,
        Definitions, //определения
        InitialisationListPattern, //список инициализации паттерн
        PatternInitialisator, // паттерн инициализатор
        Pattern, //паттерн
        Initialisator, //инициализатор
        ForInCycle,
        WhileCycle,
        Condition, //условие
        TransformationOptional, //преобразование optional
        IfBranching,
        ElseBlock,
        IdentificatorsStart,
        IdentificatorsSymbols, //символы идентификатора
        IdentificatorSymbol, //идентификатор символ
        NumberLiteral, //численный литерал
        StringLiteral,
        BoolLiteral,
        IntNumberLiteral,
        FloatNumberLiteral,
        DecimalNumber,
        DecimalSymbols,
        DecimalSymbol,
        FloatPart,
        Exp, //експонента
        Sign, //знак

        SigmaLetters,
        SigmaNumbers,
        SigmaOpenRound,
        SigmaCloseRound,
        SigmaOpenCurl,
        SigmaCloseCurl,
        SigmaEqual,
        SigmaSlash,
        SigmaStar,
        SigmaPlus,
        SigmaMinus,
        SigmaPercent,
        SigmaNot,
        SigmaQuest,
        SigmaMore,
        SigmaLess,
        SigmaDot,
        SigmaDoubleDot,
        SigmaComma,
        SigmaLambda,
        SigmaAnd,
        SigmaOr,
        SigmaFor,
        SigmaIf,
        SigmaIn,
        SigmaLet,
        SigmaVar,
        SigmaWhile,
        SigmaElse,
        SigmaBreak,
        SigmaContinue,
        SigmaTrue,
        SigmaFalse,